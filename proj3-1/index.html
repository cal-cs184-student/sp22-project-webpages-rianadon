<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
    div.padded {
      padding-top: 0px;
      padding-right: 100px;
      padding-bottom: 0.25in;
      padding-left: 100px;
    }
  </style>
<title>Your Name  |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">Assignment 3: PathTracer</h1>
    <h2 align="middle">Ryan Adolf & Natalie Kemper</h2>

    <div class="padded">
        <p>Use this section to write an overview of the assignment. All of the text in your write-up should be <em>in your own words</em>. If you need to add additional HTML features to this document, you can search the <a href="http://www.w3schools.com/">http://www.w3schools.com/</a> website for instructions. To edit the HTML, you can just copy and paste existing chunks and fill in the text and image file names appropriately.</p>
        <o>The website writeup is intended to be a self-contained walkthrough of the assignment: we want this to be a piece of work which showcases your understanding of relevant concepts through both mesh images as well as written explanations about what you did to complete each part of the assignment. Try to be as clear and organized as possible when writing about your own output files or extensions to the assignment. We want to understand what you've achieved and how you've done it!</p>
        <p>If you are well-versed in web development, feel free to ditch this template and make a better looking page. Just make sure that you include all the components as we've laid them out here. </p>

    <h2 align="middle">Part 1: Ray Generation and Intersection</h2>
        <p>Describe what you did in Part 1. etc...</p>
        <div align="center">
            <table style="width=100%">
                <tr>
                    <td align="middle">
                    <img src="images/example_image.png" width="480px" />
                    <figcaption align="middle">Results Caption: my bunny is the bounciest bunny</figcaption>
                </tr>
            </table>
        </div>
        <p>Here is an example of how to include a simple formula:</p>
        <p align="middle"><pre align="middle">a^2 + b^2 = c^2</pre></p>
        <p>or, alternatively, you can include an SVG image of a LaTex formula.</p>
        <p>This time it's your job to copy-paste in the rest of the sections :)</p>

				<h2 align="middle">Part 2: Bounding Volume Hierarchy</h2>
		        <p>For part 2, we implemented a bounding volume hierarchy (BVH) in order to accelarate our path tracer so that
							it can render complex files more efficiently. With a naive implementation, the path tracer rendered simple images
							in 40 - 60 seconds. This is fairly inefficienct because the path tracer was checking if each ray was intersecting every object in the scene, even
              if the ray completely missed the object. This inefficiency is resolved with BVH, which that uses a simple heuristic to "bound" the object in a
              simple box to first check whether the ray hits the box. If they ray intersects, the box, the object is recursively split into smaller bounding
              boxes to check if the ray still intersects. Essentially, we constructed a tree that stores a list of object primitives along with their bounding boxes.
              This simple algorithm greatly improves rendering times because the ray is not arbitrarily checking the millions of primitives in a scene. </p>

            <p>To begin constructing BVH accelaration, we first needed to choose a way we wanted to split our objects up, (a heuristic.) We chose to split the
            object in half based on its longest axis. To do this, we first created a bounding box of all of the primitives' centroids, and used the bounding box
            attribute <code>.extent</code>, which is a vector spanning the extent of the bounding box (min corner -> max coner), to find the largest of the the
            x, y and z coordinates. The largest coordinate would tell us which axis is the longest. After finding the longest axis, we calculated the midpoint of this axis
            as the split point heuristic to split our object primitives. </p>

						<p>Then, we began to construct our BVH. A BVH leaf node stores a list of object primitives and their bounding boxes, and a BVH node stores the
            larger bounding box of all objects and pointers to its left and right nodes. For our implementation, we first looped through all primitives and stored
            them in one large bounding box. From there, we checked whether the number of primitives was <code><= max_leaf_size</code> where <code>max_leaf_size</code>
            is an upper bound to how many primitives a leaf node should contain. If there were more primitives than <code>max_leaf_size</code>, we partitioned our
            primitive list using <code>std::partition</code> and our heuristic. The partition function works as follows: If the primitive's centroid was < the splitpoint of the longest axis,
            we leave the primitive in the front of the list. However, if the primitive's centroid is >= the splitpoint on the longest axis, the primitive is moved to the back
            of the list. Essentially, this creates two halves of one list, the first half < splitpoint and the second half >= splitpoint. After partitioning, we created
            the root BVH node holding all of the primitives in one bounding box, and used tree recusion to construct the left and right child nodes with our partitioned primitive list. "</p>

            <p>After completing BVH, we implemented several recursive BVH intersection functions that returns true if a ray has intersected with a bounding box and stores information
            on where the closest intersection took place. To do this, we used the ray and axis-aligned box intersection method as well as the BVH recursive traversal method as seen below. Using these
            two algorithms, we were able to effectively check whether a ray intersected a bounding box.</p>

            <div align="center">
                <table style="width=100%">
                    <tr>
                        <td>
                            <img src="images/part2/intersect.png" align="middle" width="480px" />
                            <figcaption align="middle">BVH Recursive Traversal</figcaption>
                        </td>
                        <td>
                            <img src="images/part2/boxalign.png" align="middle" width="480px" />
                            <figcaption align="middle">Axis-Aligned Box Intersection</figcaption>
                        </td>
                    </tr>
                </table>
            </div>

            <p> After fully implementing BVH, we were able to render beautiful and complex images in seconds. For example, with our native implementation, Cow.dae took roughly 1 min 40 seconds
            (100 seconds) to render. However, with BVH implemented, it took a whopping 0.2444 seconds! Furthermore, when testing on more complex files, MaxPlanck.dae took roughly 11 min 48 seconds (708 seconds) to render with
          the naive implementation compared to the BVH render time of 0.348 secondsâ€”roughly 2000x speedup! </p>

          <p> Some scenes, like Dragon.dae, were too complex for the naive implementation to render! However, after implementing BVH, we were able to render complex scenes with intricate
          geometry and mesh. For example, Dragon.dae to about 0.274 - 0.596 seconds to render with BVH. Thus, it is very apparent that this simple algorithm was able to reduce our render times
        significantly. The BVH implementation, a good heuristic, and our intersect functions are able to effectively pick which bounding boxes intersect with rays, and disregard other bounding boxes that do not intersect
        with the ray at all. This enables us to reduce redundancies, and greatly reduce up our ray intersect runtime complexity from linear O(n) to logarithmic O(log(n)). </p>

        <p> Pictured below are a few files, randing from simple to complex, after BVH implementation.</p>

            </aside> </p>
		        <div align="middle">
		            <table style="border-collapse: collapse">
		                <tr>
                      <td class="loops"><img src="images/part2/cow2.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/cow1.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/cow3.png" width="400px" align="middle" /></td>
		                </tr>
		            </table>
                <figcaption align="middle">Cow.dae! This took about 0.2 seconds to render with BVH implementation.</figcaption>
		        </div>
            <div align="middle">
		            <table style="border-collapse: collapse">
		                <tr>
                      <td class="loops"><img src="images/part2/max2.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/max1.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/max3.png" width="400px" align="middle" /></td>
		                </tr>
		            </table>
                <figcaption align="middle">MaxPlanck.dae! This mesh, comprised of thousands of triangles, took about 0.3 seconds to render with BVH.</figcaption>
		        </div>
            <div align="middle">
		            <table style="border-collapse: collapse">
		                <tr>
                      <td class="loops"><img src="images/part2/dragon2.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/dragon1.png" width="400px" align="middle" /></td>
                      <td class="loops"><img src="images/part2/dragon3.png" width="400px" align="middle" /></td>
		                </tr>
		            </table>
                <figcaption align="middle">Dragon.dae! This mesh, comprised of millions of triangles, took about 0.4 seconds to render with BVH.</figcaption>
		        </div>



    <h2 align="middle">A Few Notes On Webpages</h2>
        <p>Here are a few problems students have encountered in the past. You will probably encounter these problems at some point, so don't wait until right before the deadline to check that everything is working. Test your website on the instructional machines early!</p>
        <ul>
        <li>Your main report page should be called index.html.</li>
        <li>Be sure to include and turn in all of the other files (such as images) that are linked in your report!</li>
        <li>Use only <em>relative</em> paths to files, such as <pre>"./images/image.jpg"</pre>
        Do <em>NOT</em> use absolute paths, such as <pre>"/Users/student/Desktop/image.jpg"</pre></li>
        <li>Pay close attention to your filename extensions. Remember that on UNIX systems (such as the instructional machines), capitalization matters. <pre>.png != .jpeg != .jpg != .JPG</pre>
        <li>Be sure to adjust the permissions on your files so that they are world readable. For more information on this please see this tutorial: <a href="http://www.grymoire.com/Unix/Permissions.html">http://www.grymoire.com/Unix/Permissions.html</a></li>
        <li>And again, test your website on the instructional machines early!</li>
</div>
</body>
</html>
