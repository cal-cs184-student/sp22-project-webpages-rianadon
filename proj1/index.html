<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 1: Rasterizer</h1>
<h2 align="middle">Natalie Kemper and Ryan Adolf</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<h3 align="middle">Part 2: Antialiasing triangles</h3>

<p>In order to super-sample, we scaled the sample buffer up by sqrt(sample rate).
A point in the framebuffer (x,y) maps to the sample buffer points in the r x r rectangle with top-left corner (x*r, y*r), where r = sqrt(sample rate).</p>

<p>For drawing a point at (x,y) (<code>fill_pixel</code>), we fill that r x r rectangle with top-left corner (x, y) with the given color.</p>

<p>For drawing triangles, we scale the x0, y0, x1, ... coordinates by amount by which the sample buffer is scaled up. That way these coordinates map to the sample space. Compared to the previous triangle code, the only difference is that rather than compute the in-triangle test on the framebuffer-space points, we compute the tests with the sample-space points.</p>

<p>To finally fill the framebuffer, we average the colors in each r x r rectangle in the sample buffer. This average color is used for the corresponding point in the framebuffer.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task2-1.png" align="middle" width="300px"/>
        <figcaption align="middle">Supersampling at rate 1.</figcaption>
      </td>
      <td>
        <img src="images/task2-4.png" align="middle" width="300px"/>
        <figcaption align="middle">Supersampling at rate 4.</figcaption>
      </td>
      <td>
        <img src="images/task2-16.png" align="middle" width="300px"/>
        <figcaption align="middle">Supersampling at rate 16.</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<p>At rate 1, every pixel in the zoomed-in region is either full pink or white, as the frame buffer and sample buffer are the same size.</p>
<p>At rate 4, every pixel has 5 possible colors: white (0 pixels in triangle), slightly pink (1 pixel in triangle), somewhat pink (2 pixels in triangle), quite pink (3 pixels in triangle), and full pink (4 pixels in triangle). This allows for the edges to be softer.</p>
<p>At rate 16, every pixel has 17 possible colors, which allows for even softer edges especially at the edges that are very slightly rotated. The bottom most edge of the triangle looks similar since the softness is bounded by the sampling rate of the frame buffer, and 4 points is enough to soften this edge.</p>

<h3 align="middle">Part 3: Transforms</h3>



<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>

<p>Barycentric coordinates parameterize the interior of the triangle by writing an (x,y) coordinate, which is in terms of the screen space, into a (⍺, β, γ) coordinate that is in terms of distances to the triangle's vertices.</p>

<div align="center">
  <img src="images/task4.png" align="middle" height="400px"/>
</div>

<p>Above is a triangle whose interior colors have been interpolated with barycentric coordinates. The yellow, cyan, and magenta colors correspond to barycentric coordinates (1, 0, 0), (0, 1, 0), and (0, 0, 1), which define the corners of the triangle. As one moves farther from the triangle corner, the other colors start to blend in as the original corner's color is reduced. The center, which is equidistant from all corners, has barycentric coordinates (1/3, 1/3, 1/3) and is colored grey, an equal mix of all 3 colors.

<div align="center">
  <img src="images/task4-test7.png" align="middle" height="400px"/>
</div>

Above: Screenshot of <code>test7.svg</code>.

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<p>Level sampling finds the best texture resolution for a triangle by calculating at what rate the uv coordinates advance in that region then using the mipmap corresponding to that resolution level.</p>

<p>To find this rate, we take the derivatives of texture coordinates respective to x and y. If f(x) gives the texture coordinates at position x, we estimate ∂/∂x f(x,y) by taking f(x+1,y)-f(x,y)/1. Here texture coordinates are the uv coordinates multiplied by the texture resolution.</p>

<p>Once we have the norms of ∂/∂x f(x) and ∂/∂y f(y), we take the maximum to get the maximum rate of change of texture coordinates. The mipmap level is the log2 of this rate of change.</p>

<p>Once we have the level, it is important to check that it is valid (at least zero, less than the max mipmap level), otherwise we get a segfault! Nearest-neighbor level sampling rounds the logarithm and uses the result as the sample. Trilinear sampling calculates the color at the logarithm rounded up and rounded down then interpolates between the two colors depending on which the log is closest to.</p>

<table>
  <tr>
    <th></th>
    <th>Speed</th>
    <th>Memory usage</th>
    <th>Antialiasing Power</th>
  </tr>
  <tr>
    <th width="100">Pixel Sampling</th>
    <td>Switching form nearest-neighbor to bilinear filtering will sample 4 locations for every pixel and interpolate them, causing the sampling code to become slower (about 4x slower).</td>
    <td>There is only slight increase in memory usage due to storing some extra colors per loop iteration.</td>
    <td>Smallest antialiasing power: uses the information from adjacent pixels to reduce aliasing in textures but cannot eliminate all the high frequencies.</td>
  </tr>
  <tr>
    <th>Level Sampling</th>
    <td>There is a performance penality from needing to compute derivatives and calculate the level at every pixel. However, the mipmaps that are read will be smaller, which may speed up the program due to better caching performance.</td>
    <td>Our program loads all the mipmaps levels at once, so memory usage is not lower. However, we could in theory decrease memory usage by only loading the mipmaps levels we need.</td>
    <td>Medium antialiasing power: the reduced-size mipmaps can take advantage of more computationally expensive filtering algorithms, but only aliasing on textures are eliminated.</td>
  </tr>
  <tr>
    <th># Samples per Pixel</th>
    <td>There is a large decrease in performance because if the number of samples per pixel doubles, double the number of pixels need need to be rendered, which exercises all rendering code paths (triangle equations, samping, interpolation, etc) twice.</td>
    <td>Memory usage scales with the number of samples per pixel, which will double memory used if you are doubling the number of samples per pixel.</td>
    <td>Biggest antialiasing power: because it can antialias not only textures but also normal shapes. However, achieving this level of antialiasing requires increasing the # of samples per pixel by 4x or 9x or even 16x.</td>
  </tr>
</table>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images/task6-zero-nearest.png" align="middle" width="300px"/>
        <figcaption align="middle">L_ZERO and P_NEAREST</figcaption>
      </td>
      <td>
        <img src="images/task6-zero-linear.png" align="middle" width="300px"/>
        <figcaption align="middle">L_ZERO and P_LINEAR</figcaption>
      </td>
    </tr>
    <tr>
      <td>
        <img src="images/task6-nearest-nearest.png" align="middle" width="300px"/>
        <figcaption align="middle">L_NEAREST and P_NEAREST</figcaption>
      </td>
      <td>
        <img src="images/task6-nearest-linear.png" align="middle" width="300px"/>
        <figcaption align="middle">L_NEAREST and P_LINEAR</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>

<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>

</body>
</html>
